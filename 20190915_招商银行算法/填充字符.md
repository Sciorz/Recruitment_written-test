## 题目描述

老板给了小招喵一个由数字字符‘0’到‘9’和’?‘组成的字符串。

他让小招喵把所有‘?’用数字字符‘0’到'9‘填上，小招喵想知道有多少种情况该字符串表示的数字模13余数为5。

老板允许填出来的数字有前导零，因为答案可能很大，输出答案对10^9+7取模的结果。

## 输入描述  

输入一行数字表示老板给小招喵的字符串。

1≤|s|≤10^9，其中|s|表示字符串的长度。

## 输出描述

一行表示答案，因为答案可能很大 ，输出答案对10^9+7取模的结果。

## 示例1

### 输入

2??

### 输出

8

### 说明

满足条件的有：

200 213 226 239 252 265 278 291

## 示例2

### 输入

???5

### 输出

77

## 思路

基础动态规划。

dp_i_j表示前i位确定后%13=j的方案数。

转移方程：

$ (dp[i][(j+k*10)\%13] += dp[i-1][k])\%=mod; $ (j为第i位的取值，k为前i-1位%13的结果)

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,mod=1e9+7;
typedef long long ll;
int n,m,k,t;
char a[maxn];
ll dp[maxn][13];
int main()
{
    int i,j;
    //freopen("in.txt","r",stdin);
    scanf("%s",a+1);
    int len=strlen(a+1);
    dp[0][0]=1;
    for(i=1;i<=len;i++)
    {
        if(a[i]=='?')
        {
            for(j=0;j<10;j++)
            {
                for(k=0;k<13;k++)
                {
                    (dp[i][(j+k*10)%13]+=dp[i-1][k])%=mod;
                }
            }
        }
        else
        {
            for(j=0;j<13;j++)
            {
                (dp[i][(j*10+a[i]-'0')%13]+=dp[i-1][j])%=mod;
            }
        }
    }
    printf("%lld\n",dp[len][5]);
    return 0;
}
```

