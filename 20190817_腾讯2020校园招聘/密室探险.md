## 描述

小Q在假期的时候去一个密室探险，这个密室可以看成一个n * 3的格子，小Q最开始可以选择第一行的任意个格子进入，此后的每一步，他可以洗择下一行的当前位置或左侧一格或右侧一格，简单的说，假设小Q当前坐标为(x，y)，那么他下一步可以前进至(x+1，y-1)或(x+1，y)或(x+1y+1)，但他不能走出格子。每个格子都有一个数字，代表走到该格子可以得到的分数，但密室中有一些魔法格子，他们的数字为0，当小Q经过魔法格子后，他在之后得到的分数都会取相反数，分数可多次反转，请向小Q在探险至密室的最后一行后，最多能得到多少分呢?

## 输入描述:

输入第一行将包含一个数字，n，代表密室的行数。之后的n行每行包含3个数字w，代表密室每一行的三个数字。1 <= n <= 100000；-100000 <= w <= 100000;

## 输出描述  

输出一个数字，代表小Q可以获得的最高分数。

## 示例1

### 输入

6

1 2 3

8 9 10

5 0 5

-9 -8 -10

0 1 2

5 4 6

### 输出

27

### 说明

小Q走3 -> 10 -> 0 -> -9 -> 0 -> 5这条路径将得到的最高分数，其中-9将取相反数，得9分。

## 思路

动态规划，三维dp。

第一维表示当前反转之后增益乘积为1还是-1；

第二维表示当前在第几行；

第三维表示是当前行第几列；

转移方程：

dp_i_j_k = max(dp_i_j_k, dp_x_j-1_z + a_i_j_k * p)，p代表当前增益（1或-1）

## 代码

```python
n = int(input())
a = {}
for i in range(1,n+1):
    a[i] = list(map(int,input().split()))

dp = [[[-10**18 for i in range(3)] for j in range(n+1)] for k in range(2)]
dp[0][0][1] = 0
for i in range(0,n):
    for j in range(2):
        for k in range(3):
            if dp[j][i][k] == -10**18:
                continue
            if k-1>=0:
                to = (j^(a[i+1][k-1]==0))
                dp[to][i+1][k-1] = max(dp[to][i+1][k-1],dp[j][i][k]+a[i+1][k-1]*(1 if j ==0 else -1))
            to = (j ^ (a[i + 1][k] == 0))
            dp[to][i + 1][k] = max(dp[to][i + 1][k], dp[j][i][k] + a[i + 1][k] * (1 if j == 0 else -1))
            if k+1 < 3:
                to = (j ^ (a[i + 1][k+1] == 0))
                dp[to][i + 1][k+1] = max(dp[to][i + 1][k+1], dp[j][i][k] + a[i + 1][k+1] * (1 if j == 0 else -1))
print(max(max(dp[0][n]),max(dp[1][n])))
```

