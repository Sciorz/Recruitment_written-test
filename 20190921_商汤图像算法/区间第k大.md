## 题目描述

小A有n个糖果，这天，他的m个朋友将要来拜访，小A将自己所有的糖果摆成一排，编号为1，2,...,n，其对应的好吃程度为a_1...a_n。每个朋友来后，会从区间[l_x,r_x]的糖果中依次选择好吃程度最小的k个糖果吃掉(因为不好意思吃太好吃的)。若这个区间糖果数量比k少，就把区间内所有糖果全吃掉。若区间内没有糖果，则输出-1。

也就是说，问题是这样的，给定一个数列，多次询问，每次询问其中的一个区间，将其中最小的k个数字一个一个去掉(若区间内的数字个数小于k，就全去掉），并请输出去掉的最后一个数字是多少。若区间内没有数字，则输出-1。

此题中，所有数据均为随机生成。

10% 的数据满足n<=100,m<=10;

20% 的数据满足n<=1000,m<=20;

20%的数据满足n<=10000,m<=20;

50%的数据满足n<=1000000,m<=40;

除此之外，所有数据满足1<=l<=r<=n,1<=k<=n,1<=k<=10^9，保证所有数据均为随机生成。

## 输入描述  

第一行两个整数n，m，代表总糖果个数是n，朋友个数是m

接下来n个整数a_1...a_n，代表这n个糖果的对应好吃程度。

接下来m行，每行三个整数，l，r，k，分别代表区间的范围和选择的糖果个数。

## 输出描述

输出m个数字，代表这个朋友吃掉的最后一个糖果是哪个

## 示例1

### 输入

4 3
1 2 3 4
1 4 2
1 3 2
1 2 1

### 输出

2
3
-1

## 思路

由于m很小，且数据均为随机生成，考虑m次暴力求解，即每次对询问区间排序，并将用掉的置为-1即可，每次遇到-1就跳过。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e6+10,mod=1e9+7;
typedef long long ll;
int n,m,k,t;
int a[maxn],id[maxn];
bool cmp(int x,int y)
{
    return a[x]<a[y];
}
int main()
{
    int i,j;
    //freopen("in.txt","r",stdin);
    scanf("%d%d",&n,&m);
    for(i=1;i<=n;i++)
    {
        scanf("%d",&a[i]);
        id[i]=i;
    }
    while(m--)
    {
        int x,y,z;
        scanf("%d%d%d",&x,&y,&z);
        sort(id+x,id+y+1,cmp);
        int ret=-1;
        for(i=x;i<=y;i++)
        {
            int cur=a[id[i]];
            if(!~cur)continue;
            ret=cur;
            a[id[i]]=-1;
            if(!--z)break;
        }
        for(i=x;i<=y;i++)id[i]=i;
        printf("%d\n",ret);
    }
    return 0;
}
```

