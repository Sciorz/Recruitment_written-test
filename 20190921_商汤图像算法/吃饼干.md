## 题目描述

 小A有k-1个朋友。有一天，亲戚家托他的朋友给他一块长为n，宽为m的正方形饼干，需要通过k-1个朋友传下去最后交给他。由于小A的朋友喜"贪污"一部分饼干，每次传递时，这 个会产生传递来的饼干面积的"高兴值”，在传递过程中，他的每个朋友都会人获得的饼干中取出一个子矩形(子矩形不包含自身，行和列都得小于刚开始的值）。需要注意，最终交给小A，小A也会产生高兴值)。请问对于所有的可能情况中，高兴值积之和是多大呢?

有一个大矩形，我们要经过k个人之手，共k-1次从大矩形中选择一个子矩形。请问对于所有选择的情况来说，这K次的矩形面积之积的和是多大呢? 

比如一个3 * 3的矩形，可以从中选择4种2 * 2的矩形（因为横着有两种选法，纵着也有两种选法），这四种方案要分开计算，然后求和。也就是若询问为3 * 3的矩形，选2次，从3 * 3选2*2会让答案加上（3 * 3） * （2 * 2）*4。

也就是说，问题是这样的，从一个大矩形每次选一个长和宽都小于它的子矩形，然后求选了k次以后（k次包括初始矩形），选的这k个矩形面积之积，然后对所有选择的情况的积求和。

答案对998244353取模。

## 输入描述

共三个数字n、m、k，分别代表饼干的长宽和小A加上朋友的总人数。

## 输出描述

各测试用例在1行内输出一个整数，代表这次询问的答案。

## 示例1

### 输入

4 4 2

### 输出

4096

### 说明

答案为4 * 4 *（1 * 1 * 4 * 4 + 1 * 2 * 4 *3 + 1 * 3 * 4 * 2 + ... + 3 * 3 * 2 * 2） = 4096

## 思路

观察可以得出行和列是独立的。

那么有积的和转化为和的积，行列分别算出总的长度和即可。

算所有方案的长度和可以考虑动态规划，分别维护sum数组和dp数组。

sum数组代表当前累计增量之和，dp表示当前长度之和。

进一步优化空间可以使用滚动数组。

## 代码

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxn=1e5+10,mod=998244353;
typedef long long ll;
int n,m,k,t;
ll dp[2][510],sum[2][510];
int main()
{
    int i,j;
    //freopen("in.txt","r",stdin);
    scanf("%d%d%d",&n,&m,&k);
    ll reta,retb;
    int cur=0;
    for(i=1;i<=max(n,m);i++)
    {
        cur^=1;
        for(j=1;j<=k;j++)
        {
            if(j==1)dp[cur][j]=i;
            else dp[cur][j]=(i*(dp[cur^1][j-1]+sum[cur^1][j-1])%mod)%mod;
            if(i==n && j==k)reta=dp[cur][j];
            if(i==m && j==k)retb=dp[cur][j];
            sum[cur][j]=(sum[cur^1][j]+dp[cur][j])%mod;
            (dp[cur][j]+=(dp[cur^1][j]+sum[cur^1][j])%mod)%=mod;
        }
    }
    printf("%d\n",reta*retb%mod);
    return 0;
}
```

